# ğŸš€ AIé‡åŒ–äº¤æ˜“ç³»ç»Ÿ - é•¿æœŸä¼˜åŒ–æ–¹æ¡ˆ

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**åˆ›å»ºæ—¶é—´**: 2025-12-18  
**è§„åˆ’å‘¨æœŸ**: 3-6ä¸ªæœˆ  
**ç›®æ ‡**: å»ºç«‹å¥å£®ã€å¯é ã€å¯æ‰©å±•çš„é‡åŒ–äº¤æ˜“ç³»ç»Ÿ

---

## ğŸ“‹ ç›®å½•

1. [ä¼˜åŒ–ç›®æ ‡](#ä¼˜åŒ–ç›®æ ‡)
2. [æ¶æ„é‡æ„](#æ¶æ„é‡æ„)
3. [æ•°æ®æµä¼˜åŒ–](#æ•°æ®æµä¼˜åŒ–)
4. [é£æ§ä½“ç³»](#é£æ§ä½“ç³»)
5. [æµ‹è¯•ä½“ç³»](#æµ‹è¯•ä½“ç³»)
6. [ç›‘æ§å‘Šè­¦](#ç›‘æ§å‘Šè­¦)
7. [æ–‡æ¡£è§„èŒƒ](#æ–‡æ¡£è§„èŒƒ)
8. [å®æ–½è·¯çº¿å›¾](#å®æ–½è·¯çº¿å›¾)

---

## ğŸ¯ ä¼˜åŒ–ç›®æ ‡

### æ ¸å¿ƒç›®æ ‡

1. **æ•°æ®å¯é æ€§**: 100%çš„æ•°æ®ä¸€è‡´æ€§å’Œå¯è¿½æº¯æ€§
2. **ç­–ç•¥å‡†ç¡®æ€§**: æŠ€æœ¯æŒ‡æ ‡ç¬¦åˆç»å…¸é‡‘èå®šä¹‰
3. **é£æ§ä¸¥æ ¼æ€§**: é›¶é£æ§æ¼æ´ï¼Œç¬¦åˆäº¤æ˜“æ‰€è§„èŒƒ
4. **ç³»ç»Ÿå¥å£®æ€§**: æ•…éšœè‡ªåŠ¨æ¢å¤ï¼Œæ•°æ®å®Œæ•´æ€§ä¿è¯
5. **å¯ç»´æŠ¤æ€§**: ä»£ç ä¸æ–‡æ¡£åŒæ­¥ï¼Œæ˜“äºè°ƒè¯•å’Œæ‰©å±•

### é‡åŒ–æŒ‡æ ‡

| æŒ‡æ ‡ | å½“å‰çŠ¶æ€ | ç›®æ ‡çŠ¶æ€ |
|------|---------|---------|
| ä»£ç æµ‹è¯•è¦†ç›–ç‡ | ~10% | >80% |
| æ•°æ®éªŒè¯ç‡ | æ‰‹åŠ¨ | 100%è‡ªåŠ¨åŒ– |
| æ–‡æ¡£åŒæ­¥ç‡ | ~60% | 100% |
| é£æ§å‡†ç¡®ç‡ | ~85% | 100% |
| ç³»ç»Ÿå¯ç”¨æ€§ | ~95% | >99.5% |

---

## ğŸ—ï¸ æ¶æ„é‡æ„

### 1. åˆ†å±‚æ¶æ„è®¾è®¡

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           åº”ç”¨å±‚ (Application Layer)             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚ Web UI   â”‚  â”‚ CLI Tool â”‚  â”‚ Schedulerâ”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           ä¸šåŠ¡å±‚ (Business Layer)                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚ Strategy â”‚  â”‚ Decision â”‚  â”‚ Executionâ”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           æœåŠ¡å±‚ (Service Layer)                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚ DataProc â”‚  â”‚ RiskMgmt â”‚  â”‚ Indicatorâ”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           æ•°æ®å±‚ (Data Layer)                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚ Database â”‚  â”‚ Cache    â”‚  â”‚ FileStoreâ”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           åŸºç¡€è®¾æ–½å±‚ (Infrastructure)            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚ Binance  â”‚  â”‚ DeepSeek â”‚  â”‚ Monitor  â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. æ ¸å¿ƒæ¨¡å—é‡æ„

#### 2.1 æ•°æ®å¤„ç†æ¨¡å— (DataProcessor)

**å½“å‰é—®é¢˜**:
- âŒ æ··åˆäº†æ•°æ®å¤„ç†å’Œç‰¹å¾å·¥ç¨‹
- âŒ ç¼ºä¹æ•°æ®éªŒè¯æœºåˆ¶
- âŒ å¤šå‘¨æœŸæ•°æ®ç‹¬ç«‹æ€§ä¸è¶³

**é‡æ„ç›®æ ‡**:
```python
# æ–°æ¶æ„
class DataProcessor:
    """çº¯æ•°æ®å¤„ç†ï¼Œä¸æ¶‰åŠç‰¹å¾å·¥ç¨‹"""
    
    def process_klines(self, klines, symbol, timeframe):
        """å¤„ç†Kçº¿æ•°æ®"""
        # 1. æ•°æ®æ¸…æ´—å’ŒéªŒè¯
        df = self._validate_and_clean(klines)
        
        # 2. è®¡ç®—ç»å…¸æŠ€æœ¯æŒ‡æ ‡ï¼ˆä¿æŒåŸå§‹å®šä¹‰ï¼‰
        df = self._calculate_indicators(df)
        
        # 3. æ ‡è®°warmupæœŸï¼ˆ105æ ¹ï¼‰
        df = self._mark_warmup_period(df, warmup=105)
        
        # 4. ç”Ÿæˆç¡®å®šæ€§å¿«ç…§ID
        snapshot_id = self._generate_snapshot_id(symbol, timeframe, df)
        
        # 5. æ•°æ®å®Œæ•´æ€§æ ¡éªŒ
        self._validate_output(df)
        
        return df

class FeatureEngineer:
    """ä¸“é—¨çš„ç‰¹å¾å·¥ç¨‹æ¨¡å—"""
    
    def build_features(self, df):
        """ä»åŸå§‹æŒ‡æ ‡æ„å»ºç‰¹å¾"""
        features = pd.DataFrame()
        
        # 1. å½’ä¸€åŒ–ç‰¹å¾
        features['macd_pct'] = (df['macd'] / df['close']) * 100
        
        # 2. æŠ€æœ¯å½¢æ€ç‰¹å¾
        features['golden_cross'] = self._detect_golden_cross(df)
        
        # 3. å¤šå‘¨æœŸç‰¹å¾
        features['trend_alignment'] = self._calculate_trend_alignment(df)
        
        return features
```

#### 2.2 é£æ§ç®¡ç†æ¨¡å— (RiskManager)

**å½“å‰é—®é¢˜**:
- âŒ MIN_NOTIONALæ£€æŸ¥å¯¹è±¡é”™è¯¯
- âŒ ç¼ºä¹å¤šå±‚çº§é£æ§
- âŒ æ­¢æŸ/æ­¢ç›ˆè®¡ç®—ç¼ºä¹éªŒè¯

**é‡æ„ç›®æ ‡**:
```python
class RiskManager:
    """å¤šå±‚çº§é£æ§ç³»ç»Ÿ"""
    
    def __init__(self):
        self.validators = [
            MinNotionalValidator(),      # æœ€å°åä¹‰é‡‘é¢
            LeverageValidator(),          # æ æ†é™åˆ¶
            PositionSizeValidator(),      # ä»“ä½å¤§å°
            DrawdownValidator(),          # å›æ’¤æ§åˆ¶
            ConsecutiveLossValidator(),   # è¿ç»­äºæŸ
            FundingRateValidator(),       # èµ„é‡‘è´¹ç‡
            LiquidityValidator(),         # æµåŠ¨æ€§
        ]
    
    def validate_trade(self, decision, account, market):
        """å¤šå±‚çº§é£æ§éªŒè¯"""
        for validator in self.validators:
            passed, modified, reason = validator.validate(
                decision, account, market
            )
            if not passed:
                return False, modified, reason
        
        return True, decision, "é€šè¿‡æ‰€æœ‰é£æ§æ£€æŸ¥"

class MinNotionalValidator:
    """æœ€å°åä¹‰é‡‘é¢éªŒè¯å™¨"""
    
    def validate(self, decision, account, market):
        # è®¡ç®—åä¹‰ä»·å€¼ï¼ˆä¸æ˜¯ä¿è¯é‡‘ï¼ï¼‰
        margin = account['balance'] * decision['position_pct'] / 100
        notional_value = margin * decision['leverage']
        
        if notional_value < self.MIN_NOTIONAL:
            return False, decision, f"åä¹‰ä»·å€¼{notional_value}<{self.MIN_NOTIONAL}"
        
        return True, decision, "é€šè¿‡MIN_NOTIONALæ£€æŸ¥"
```

#### 2.3 å¿«ç…§IDç®¡ç† (SnapshotManager)

**å½“å‰é—®é¢˜**:
- âŒ ç¼ºä¹ä¸Šä¸‹æ–‡ä¿¡æ¯
- âŒ UUIDç¢°æ’é£é™©
- âŒ æ— æ³•è‡ªåŠ¨å»é‡

**é‡æ„ç›®æ ‡**:
```python
class SnapshotManager:
    """ç»Ÿä¸€çš„å¿«ç…§IDç®¡ç†"""
    
    def generate_id(
        self,
        symbol: str,
        timeframe: str,
        df: pd.DataFrame,
        mode: str = 'hybrid'  # 'deterministic', 'random', 'hybrid'
    ) -> str:
        """
        ç”Ÿæˆå¿«ç…§ID
        
        mode='deterministic': ç›¸åŒæ•°æ®â†’ç›¸åŒIDï¼ˆç”¨äºå»é‡ï¼‰
        mode='random': å®Œå…¨éšæœºï¼ˆç”¨äºåŒºåˆ†è¿è¡Œï¼‰
        mode='hybrid': æ··åˆï¼ˆæ¨èï¼‰
        """
        import hashlib
        import uuid
        
        latest = df.iloc[-1]
        timestamp = latest.name.strftime('%Y%m%d_%H%M%S')
        
        if mode == 'deterministic':
            # åŸºäºå†…å®¹çš„ç¡®å®šæ€§ID
            content = f"{symbol}_{timeframe}_{timestamp}_{latest['close']:.2f}"
            hash_id = hashlib.md5(content.encode()).hexdigest()[:8]
            return f"{symbol}_{timeframe}_{timestamp}_{hash_id}"
        
        elif mode == 'random':
            # å®Œå…¨éšæœºID
            random_id = str(uuid.uuid4())[:12]
            return f"{symbol}_{timeframe}_{random_id}"
        
        else:  # hybrid
            # æ··åˆæ¨¡å¼ï¼šç¡®å®šæ€§éƒ¨åˆ† + éšæœºéƒ¨åˆ†
            content = f"{symbol}_{timeframe}_{timestamp}_{latest['close']:.2f}"
            content_hash = hashlib.md5(content.encode()).hexdigest()[:4]
            run_id = str(uuid.uuid4())[:4]
            return f"{symbol}_{timeframe}_{timestamp}_{content_hash}_{run_id}"
    
    def parse_id(self, snapshot_id: str) -> dict:
        """è§£æå¿«ç…§IDï¼Œæå–ä¸Šä¸‹æ–‡ä¿¡æ¯"""
        parts = snapshot_id.split('_')
        return {
            'symbol': parts[0],
            'timeframe': parts[1],
            'timestamp': parts[2] + '_' + parts[3],
            'content_hash': parts[4] if len(parts) > 4 else None,
            'run_id': parts[5] if len(parts) > 5 else None
        }
```

---

## ğŸ“Š æ•°æ®æµä¼˜åŒ–

### 3. å¤šå‘¨æœŸæ•°æ®ç‹¬ç«‹æ€§

**é—®é¢˜**: å½“å‰ä½¿ç”¨æœªå®ŒæˆKçº¿ï¼Œå¯¼è‡´å¤šå‘¨æœŸä»·æ ¼ç›¸åŒ

**è§£å†³æ–¹æ¡ˆ**:

```python
class MultiTimeframeDataManager:
    """å¤šå‘¨æœŸæ•°æ®ç®¡ç†å™¨"""
    
    def fetch_multiframe_data(self, symbol: str, limit: int = 100):
        """è·å–å¤šå‘¨æœŸç‹¬ç«‹æ•°æ®"""
        data = {}
        
        for timeframe in ['5m', '15m', '1h']:
            # è·å–Kçº¿
            klines = self.client.get_klines(symbol, timeframe, limit=limit)
            
            # å¤„ç†æ•°æ®
            df = self.processor.process_klines(klines, symbol, timeframe)
            
            # âœ… ä½¿ç”¨å·²å®Œæˆçš„Kçº¿ï¼ˆdf.iloc[-2]ï¼‰
            latest_completed = df.iloc[-2]
            
            data[timeframe] = {
                'price': latest_completed['close'],
                'timestamp': latest_completed.name,
                'volume': latest_completed['volume'],
                'indicators': self._extract_indicators(latest_completed),
                'snapshot_id': df.attrs['snapshot_id']
            }
            
            # ä¿å­˜åŸå§‹æ•°æ®ï¼ˆç”¨äºå®¡è®¡ï¼‰
            self.save_raw_data(df, symbol, timeframe)
        
        # éªŒè¯å¤šå‘¨æœŸç‹¬ç«‹æ€§
        self._validate_independence(data)
        
        return data
    
    def _validate_independence(self, data):
        """éªŒè¯å¤šå‘¨æœŸæ•°æ®ç‹¬ç«‹æ€§"""
        prices = [data[tf]['price'] for tf in data.keys()]
        
        # æ£€æŸ¥ä»·æ ¼æ˜¯å¦å¼‚å¸¸ä¸€è‡´
        if len(set(prices)) == 1:
            raise ValueError(
                f"âš ï¸ å¤šå‘¨æœŸä»·æ ¼å®Œå…¨ç›¸åŒï¼ç–‘ä¼¼ä½¿ç”¨äº†ç›¸åŒçš„æœªå®ŒæˆKçº¿\n"
                f"ä»·æ ¼: {prices}"
            )
        
        # æ£€æŸ¥æ—¶é—´æˆ³å¯¹é½
        for tf, state in data.items():
            ts = state['timestamp']
            if tf == '1h' and ts.minute != 0:
                raise ValueError(f"1h Kçº¿æ—¶é—´æˆ³æœªå¯¹é½æ•´ç‚¹: {ts}")
```

### 4. æ•°æ®éªŒè¯ç®¡é“

```python
class DataValidationPipeline:
    """æ•°æ®éªŒè¯ç®¡é“"""
    
    def __init__(self):
        self.validators = [
            NullCheckValidator(),         # ç©ºå€¼æ£€æŸ¥
            RangeValidator(),            # æ•°å€¼èŒƒå›´
            TimeSequenceValidator(),     # æ—¶é—´åºåˆ—
            IndicatorConsistencyValidator(),  # æŒ‡æ ‡ä¸€è‡´æ€§
            WarmupValidator(),           # warmupæœŸéªŒè¯
        ]
    
    def validate(self, df: pd.DataFrame, stage: str) -> tuple[bool, list]:
        """
        éªŒè¯æ•°æ®è´¨é‡
        
        Returns:
            (is_valid, error_messages)
        """
        errors = []
        
        for validator in self.validators:
            passed, msg = validator.validate(df, stage)
            if not passed:
                errors.append(msg)
        
        return len(errors) == 0, errors

class WarmupValidator:
    """WarmupæœŸéªŒè¯å™¨"""
    
    REQUIRED_WARMUP = {
        'macd': 105,      # MACDéœ€è¦105æ ¹
        'ema_26': 78,     # EMA26éœ€è¦78æ ¹
        'rsi': 42,        # RSIéœ€è¦42æ ¹
        'atr': 42,        # ATRéœ€è¦42æ ¹
    }
    
    def validate(self, df: pd.DataFrame, stage: str) -> tuple[bool, str]:
        """éªŒè¯warmupæœŸæ˜¯å¦å……è¶³"""
        if stage != 'step2':
            return True, ""
        
        # æ£€æŸ¥æ•°æ®é‡
        if len(df) < max(self.REQUIRED_WARMUP.values()):
            return False, f"æ•°æ®é‡ä¸è¶³ï¼Œéœ€è‡³å°‘{max(self.REQUIRED_WARMUP.values())}æ ¹"
        
        # æ£€æŸ¥warmupæ ‡è®°
        warmup_count = df['is_warmup'].sum()
        expected = max(self.REQUIRED_WARMUP.values())
        
        if warmup_count != expected:
            return False, f"warmupæœŸæ ‡è®°é”™è¯¯ï¼šå½“å‰{warmup_count}ï¼Œåº”ä¸º{expected}"
        
        return True, ""
```

---

## ğŸ›¡ï¸ é£æ§ä½“ç³»

### 5. å¤šå±‚çº§é£æ§æ¶æ„

```python
class TieredRiskControl:
    """å¤šå±‚çº§é£æ§ç³»ç»Ÿ"""
    
    def __init__(self):
        # ç¬¬ä¸€å±‚ï¼šäº¤æ˜“æ‰€è§„åˆ™
        self.exchange_rules = ExchangeRuleValidator()
        
        # ç¬¬äºŒå±‚ï¼šè´¦æˆ·é£æ§
        self.account_risk = AccountRiskValidator()
        
        # ç¬¬ä¸‰å±‚ï¼šç­–ç•¥é£æ§
        self.strategy_risk = StrategyRiskValidator()
        
        # ç¬¬å››å±‚ï¼šç´§æ€¥é£æ§
        self.emergency_risk = EmergencyRiskValidator()
    
    def validate_decision(self, decision, account, market):
        """å¤šå±‚çº§éªŒè¯"""
        # L1: äº¤æ˜“æ‰€è§„åˆ™ï¼ˆç¡¬æ€§ï¼‰
        if not self.exchange_rules.validate(decision):
            return False, "è¿åäº¤æ˜“æ‰€è§„åˆ™"
        
        # L2: è´¦æˆ·é£æ§ï¼ˆç¡¬æ€§ï¼‰
        if not self.account_risk.validate(decision, account):
            return False, "è´¦æˆ·é£æ§æ‹’ç»"
        
        # L3: ç­–ç•¥é£æ§ï¼ˆå¯è°ƒæ•´ï¼‰
        passed, modified = self.strategy_risk.validate(decision, market)
        if not passed:
            return False, "ç­–ç•¥é£æ§æ‹’ç»"
        
        # L4: ç´§æ€¥é£æ§ï¼ˆåŠ¨æ€ï¼‰
        if self.emergency_risk.is_triggered():
            return False, "ç´§æ€¥é£æ§è§¦å‘"
        
        return True, modified

class ExchangeRuleValidator:
    """äº¤æ˜“æ‰€è§„åˆ™éªŒè¯"""
    
    def validate(self, decision):
        """éªŒè¯æ˜¯å¦ç¬¦åˆBinanceè§„åˆ™"""
        checks = [
            self._check_min_notional(decision),
            self._check_step_size(decision),
            self._check_price_filter(decision),
            self._check_lot_size(decision),
        ]
        
        return all(checks)
    
    def _check_min_notional(self, decision):
        """æ£€æŸ¥æœ€å°åä¹‰é‡‘é¢ï¼ˆæ­£ç¡®å®ç°ï¼‰"""
        margin = decision['margin']
        leverage = decision['leverage']
        notional_value = margin * leverage  # âœ… åä¹‰ä»·å€¼
        
        MIN_NOTIONAL = 100.0
        
        if notional_value < MIN_NOTIONAL:
            log.error(
                f"MIN_NOTIONALæ£€æŸ¥å¤±è´¥: "
                f"margin={margin}, leverage={leverage}, "
                f"notional={notional_value} < {MIN_NOTIONAL}"
            )
            return False
        
        return True
```

### 6. æ­¢æŸ/æ­¢ç›ˆç®¡ç†

```python
class StopLossTakeProfitManager:
    """æ­¢æŸæ­¢ç›ˆç®¡ç†å™¨"""
    
    def calculate_prices(
        self,
        entry_price: float,
        side: str,
        stop_loss_pct: float,
        take_profit_pct: float
    ) -> dict:
        """
        è®¡ç®—æ­¢æŸæ­¢ç›ˆä»·æ ¼
        
        Args:
            entry_price: å…¥åœºä»·
            side: 'LONG' or 'SHORT'
            stop_loss_pct: æ­¢æŸç™¾åˆ†æ¯”ï¼ˆæ­£æ•°ï¼‰
            take_profit_pct: æ­¢ç›ˆç™¾åˆ†æ¯”ï¼ˆæ­£æ•°ï¼‰
        
        Returns:
            {'stop_loss': float, 'take_profit': float}
        """
        if side == 'LONG':
            # åšå¤šï¼šæ­¢æŸä½äºå…¥åœºï¼Œæ­¢ç›ˆé«˜äºå…¥åœº
            stop_loss = entry_price * (1 - stop_loss_pct / 100)
            take_profit = entry_price * (1 + take_profit_pct / 100)
        else:  # SHORT
            # åšç©ºï¼šæ­¢æŸé«˜äºå…¥åœºï¼Œæ­¢ç›ˆä½äºå…¥åœº
            stop_loss = entry_price * (1 + stop_loss_pct / 100)
            take_profit = entry_price * (1 - take_profit_pct / 100)
        
        # éªŒè¯é€»è¾‘æ­£ç¡®æ€§
        self._validate_sl_tp(entry_price, stop_loss, take_profit, side)
        
        return {
            'stop_loss': round(stop_loss, 2),
            'take_profit': round(take_profit, 2)
        }
    
    def _validate_sl_tp(self, entry, sl, tp, side):
        """éªŒè¯æ­¢æŸæ­¢ç›ˆé€»è¾‘"""
        if side == 'LONG':
            assert sl < entry, f"åšå¤šæ­¢æŸåº”ä½äºå…¥åœº: {sl} >= {entry}"
            assert tp > entry, f"åšå¤šæ­¢ç›ˆåº”é«˜äºå…¥åœº: {tp} <= {entry}"
        else:
            assert sl > entry, f"åšç©ºæ­¢æŸåº”é«˜äºå…¥åœº: {sl} <= {entry}"
            assert tp < entry, f"åšç©ºæ­¢ç›ˆåº”ä½äºå…¥åœº: {tp} >= {entry}"
```

---

## ğŸ§ª æµ‹è¯•ä½“ç³»

### 7. è‡ªåŠ¨åŒ–æµ‹è¯•æ¡†æ¶

```python
# tests/test_data_processing.py
import pytest
from src.data.processor import DataProcessor

class TestDataProcessor:
    """æ•°æ®å¤„ç†æ¨¡å—æµ‹è¯•"""
    
    @pytest.fixture
    def processor(self):
        return DataProcessor()
    
    def test_macd_is_classic_definition(self, processor):
        """æµ‹è¯•MACDæ˜¯å¦ä¸ºç»å…¸å®šä¹‰ï¼ˆä»·å·®ï¼‰"""
        klines = load_test_klines()
        df = processor.process_klines(klines, 'BTCUSDT', '5m')
        
        # MACDåº”ä¸ºä»·æ ¼å•ä½ï¼Œä¸æ˜¯ç™¾åˆ†æ¯”
        assert df['macd'].abs().max() > 10, "MACDåº”ä¸ºä»·æ ¼å•ä½"
        
        # MACDå ä»·æ ¼æ¯”ä¾‹åº”<5%
        macd_pct = (df['macd'] / df['close']).abs().max() * 100
        assert macd_pct < 5, f"MACDç™¾åˆ†æ¯”è¿‡é«˜: {macd_pct}%"
    
    def test_warmup_period_sufficient(self, processor):
        """æµ‹è¯•warmupæœŸæ˜¯å¦å……è¶³"""
        klines = load_test_klines(limit=200)
        df = processor.process_klines(klines, 'BTCUSDT', '5m')
        
        # warmupæœŸåº”ä¸º105æ ¹
        warmup_count = df['is_warmup'].sum()
        assert warmup_count == 105, f"warmupæœŸåº”ä¸º105ï¼Œå®é™…{warmup_count}"
    
    def test_snapshot_id_has_context(self, processor):
        """æµ‹è¯•snapshot_idåŒ…å«ä¸Šä¸‹æ–‡"""
        klines = load_test_klines()
        df = processor.process_klines(klines, 'BTCUSDT', '5m')
        
        snapshot_id = df.attrs['snapshot_id']
        
        # åº”åŒ…å«symbolå’Œtimeframe
        assert 'BTCUSDT' in snapshot_id
        assert '5m' in snapshot_id

# tests/test_risk_management.py
class TestRiskManagement:
    """é£æ§æ¨¡å—æµ‹è¯•"""
    
    def test_min_notional_with_leverage(self):
        """æµ‹è¯•MIN_NOTIONALæ£€æŸ¥ï¼ˆå«æ æ†ï¼‰"""
        validator = MinNotionalValidator()
        
        # é«˜æ æ†åœºæ™¯ï¼šä¿è¯é‡‘50ï¼Œæ æ†5xï¼Œåä¹‰ä»·å€¼250
        decision = {
            'margin': 50,
            'leverage': 5,
            'position_pct': 100
        }
        
        # åº”é€šè¿‡æ£€æŸ¥ï¼ˆåä¹‰ä»·å€¼250>100ï¼‰
        passed, _, _ = validator.validate(decision, {}, {})
        assert passed, "é«˜æ æ†äº¤æ˜“åº”é€šè¿‡MIN_NOTIONALæ£€æŸ¥"
    
    def test_stop_loss_direction(self):
        """æµ‹è¯•æ­¢æŸæ–¹å‘é€»è¾‘"""
        manager = StopLossTakeProfitManager()
        
        # åšå¤šï¼šæ­¢æŸåº”ä½äºå…¥åœº
        result = manager.calculate_prices(
            entry_price=90000,
            side='LONG',
            stop_loss_pct=1,
            take_profit_pct=2
        )
        assert result['stop_loss'] < 90000
        assert result['take_profit'] > 90000
        
        # åšç©ºï¼šæ­¢æŸåº”é«˜äºå…¥åœº
        result = manager.calculate_prices(
            entry_price=90000,
            side='SHORT',
            stop_loss_pct=1,
            take_profit_pct=2
        )
        assert result['stop_loss'] > 90000
        assert result['take_profit'] < 90000

# tests/test_multiframe.py
class TestMultiTimeframe:
    """å¤šå‘¨æœŸæ•°æ®æµ‹è¯•"""
    
    def test_prices_are_independent(self):
        """æµ‹è¯•å¤šå‘¨æœŸä»·æ ¼ç‹¬ç«‹æ€§"""
        manager = MultiTimeframeDataManager()
        data = manager.fetch_multiframe_data('BTCUSDT')
        
        prices = [data[tf]['price'] for tf in ['5m', '15m', '1h']]
        
        # ä»·æ ¼åº”ä¸å®Œå…¨ç›¸åŒ
        assert len(set(prices)) > 1, "å¤šå‘¨æœŸä»·æ ¼ä¸åº”å®Œå…¨ç›¸åŒ"
```

### 8. é›†æˆæµ‹è¯•

```python
# tests/integration/test_trading_pipeline.py
class TestTradingPipeline:
    """ç«¯åˆ°ç«¯é›†æˆæµ‹è¯•"""
    
    def test_full_trading_cycle(self):
        """æµ‹è¯•å®Œæ•´äº¤æ˜“æµç¨‹"""
        bot = TradingBot(config='test_config.yaml')
        
        # Step1: è·å–æ•°æ®
        market_data = bot.get_market_data()
        assert 'timeframes' in market_data
        
        # Step2: å¤„ç†æŒ‡æ ‡
        df = bot.processor.process_klines(...)
        assert 'macd' in df.columns
        assert df['macd'].abs().max() > 10  # ç»å…¸MACD
        
        # Step3: ç‰¹å¾å·¥ç¨‹
        features = bot.feature_engineer.build_features(df)
        assert 'macd_pct' in features.columns
        
        # Step4-6: å†³ç­–
        decision = bot.make_decision(market_data)
        
        # Step7: é£æ§éªŒè¯
        passed, modified, msg = bot.risk_manager.validate(decision)
        assert passed or "MIN_NOTIONAL" not in msg  # ä¸åº”å› MIN_NOTIONALè¯¯æ‹’
        
        # Step7: æ‰§è¡Œï¼ˆæ¨¡æ‹Ÿï¼‰
        if passed:
            result = bot.execute_trade(modified, simulate=True)
            assert result['total_value'] == result['quantity'] * result['price']
```

---

## ğŸ“ˆ ç›‘æ§å‘Šè­¦

### 9. å®æ—¶ç›‘æ§ç³»ç»Ÿ

```python
class TradingMonitor:
    """äº¤æ˜“ç›‘æ§ç³»ç»Ÿ"""
    
    def __init__(self):
        self.metrics = MetricsCollector()
        self.alerter = AlertManager()
    
    def monitor_data_quality(self, df):
        """ç›‘æ§æ•°æ®è´¨é‡"""
        # æ£€æŸ¥NaNå€¼
        nan_count = df.isnull().sum().sum()
        if nan_count > 0:
            self.alerter.send_alert(
                level='warning',
                msg=f"æ•°æ®åŒ…å«{nan_count}ä¸ªNaNå€¼"
            )
        
        # æ£€æŸ¥warmupæœŸ
        warmup_count = df['is_warmup'].sum()
        if warmup_count != 105:
            self.alerter.send_alert(
                level='error',
                msg=f"warmupæœŸå¼‚å¸¸: {warmup_count} != 105"
            )
        
        # è®°å½•æŒ‡æ ‡
        self.metrics.record('data_quality', {
            'rows': len(df),
            'nan_count': nan_count,
            'warmup_count': warmup_count
        })
    
    def monitor_risk_controls(self, decision, result):
        """ç›‘æ§é£æ§æ‰§è¡Œ"""
        # è®°å½•é£æ§å†³ç­–
        self.metrics.record('risk_decision', {
            'decision': decision['action'],
            'passed': result['passed'],
            'reason': result['reason']
        })
        
        # æ£€æµ‹å¼‚å¸¸æ‹’ç»
        if not result['passed'] and 'MIN_NOTIONAL' in result['reason']:
            margin = decision['margin']
            leverage = decision['leverage']
            notional = margin * leverage
            
            if notional >= 100:
                # åä¹‰ä»·å€¼è¶³å¤Ÿï¼Œä½†è¢«æ‹’ç»â†’é€»è¾‘é”™è¯¯
                self.alerter.send_alert(
                    level='critical',
                    msg=f"MIN_NOTIONALé€»è¾‘é”™è¯¯ï¼šnotional={notional}ä½†è¢«æ‹’ç»"
                )
    
    def generate_daily_report(self):
        """ç”Ÿæˆæ¯æ—¥æŠ¥å‘Š"""
        return {
            'total_signals': self.metrics.get('signal_count'),
            'trades_executed': self.metrics.get('trade_count'),
            'risk_rejections': self.metrics.get('risk_rejection_count'),
            'data_quality_score': self.metrics.get('data_quality_avg'),
            'errors': self.metrics.get('error_count')
        }
```

### 10. å¼‚å¸¸æ£€æµ‹

```python
class AnomalyDetector:
    """å¼‚å¸¸æ£€æµ‹å™¨"""
    
    def detect_multiframe_anomaly(self, data):
        """æ£€æµ‹å¤šå‘¨æœŸæ•°æ®å¼‚å¸¸"""
        prices = [data[tf]['price'] for tf in data.keys()]
        
        # æ£€æŸ¥ä»·æ ¼å®Œå…¨ç›¸åŒï¼ˆç–‘ä¼¼ä¼ªå¤šå‘¨æœŸï¼‰
        if len(set(prices)) == 1:
            return {
                'anomaly': 'identical_prices',
                'severity': 'critical',
                'description': 'å¤šå‘¨æœŸä»·æ ¼å®Œå…¨ç›¸åŒï¼Œç–‘ä¼¼ä½¿ç”¨æœªå®ŒæˆKçº¿'
            }
        
        # æ£€æŸ¥ä»·æ ¼å·®å¼‚è¿‡å°ï¼ˆå¯èƒ½å¼‚å¸¸ï¼‰
        price_range = max(prices) - min(prices)
        avg_price = sum(prices) / len(prices)
        if price_range / avg_price < 0.0001:  # 0.01%
            return {
                'anomaly': 'low_price_variance',
                'severity': 'warning',
                'description': f'å¤šå‘¨æœŸä»·æ ¼å·®å¼‚è¿‡å°: {price_range/avg_price*100:.4f}%'
            }
        
        return None
    
    def detect_indicator_anomaly(self, df):
        """æ£€æµ‹æŒ‡æ ‡è®¡ç®—å¼‚å¸¸"""
        anomalies = []
        
        # MACDé‡çº²æ£€æŸ¥
        macd_max = df['macd'].abs().max()
        if macd_max < 1:
            anomalies.append({
                'indicator': 'macd',
                'anomaly': 'wrong_unit',
                'description': f'MACDå€¼è¿‡å°({macd_max:.4f})ï¼Œç–‘ä¼¼ç™¾åˆ†æ¯”åŒ–'
            })
        
        # WarmupæœŸæ£€æŸ¥
        warmup_count = df['is_warmup'].sum()
        if warmup_count != 105:
            anomalies.append({
                'indicator': 'warmup',
                'anomaly': 'incorrect_period',
                'description': f'warmupæœŸé”™è¯¯: {warmup_count} != 105'
            })
        
        return anomalies
```

---

## ğŸ“š æ–‡æ¡£è§„èŒƒ

### 11. ä»£ç å³æ–‡æ¡£

```python
from typing import TypedDict, Literal

class TradingDecision(TypedDict):
    """äº¤æ˜“å†³ç­–æ•°æ®ç»“æ„
    
    Attributes:
        action: æ“ä½œç±»å‹ï¼ˆ'open_long', 'open_short', 'hold'ï¼‰
        symbol: äº¤æ˜“å¯¹ï¼ˆå¦‚'BTCUSDT'ï¼‰
        margin: ä¿è¯é‡‘ï¼ˆUSDTï¼‰
        leverage: æ æ†å€æ•°
        notional_value: åä¹‰ä»·å€¼ï¼ˆmargin Ã— leverageï¼‰
        stop_loss_pct: æ­¢æŸç™¾åˆ†æ¯”ï¼ˆæ­£æ•°ï¼‰
        take_profit_pct: æ­¢ç›ˆç™¾åˆ†æ¯”ï¼ˆæ­£æ•°ï¼‰
    
    Example:
        >>> decision = {
        ...     'action': 'open_long',
        ...     'symbol': 'BTCUSDT',
        ...     'margin': 100,
        ...     'leverage': 5,
        ...     'notional_value': 500,
        ...     'stop_loss_pct': 1,
        ...     'take_profit_pct': 2
        ... }
    """
    action: Literal['open_long', 'open_short', 'hold']
    symbol: str
    margin: float
    leverage: int
    notional_value: float  # margin Ã— leverage
    stop_loss_pct: float
    take_profit_pct: float

def calculate_position_size(
    account_balance: float,
    position_pct: float,
    leverage: int,
    current_price: float
) -> tuple[float, float, float]:
    """
    è®¡ç®—äº¤æ˜“ä»“ä½å¤§å°
    
    Args:
        account_balance: è´¦æˆ·ä½™é¢ï¼ˆUSDTï¼‰
        position_pct: ä»“ä½ç™¾åˆ†æ¯”ï¼ˆ0-100ï¼‰
        leverage: æ æ†å€æ•°
        current_price: å½“å‰ä»·æ ¼ï¼ˆUSDTï¼‰
    
    Returns:
        (quantity, margin, notional_value)
        - quantity: äº¤æ˜“æ•°é‡ï¼ˆBTCï¼‰
        - margin: ä¿è¯é‡‘ï¼ˆUSDTï¼‰
        - notional_value: åä¹‰ä»·å€¼ï¼ˆUSDTï¼‰= margin Ã— leverage
    
    Example:
        >>> calculate_position_size(
        ...     account_balance=1000,
        ...     position_pct=10,
        ...     leverage=5,
        ...     current_price=90000
        ... )
        (0.00556, 100, 500)  # quantity=0.00556 BTC, margin=100 USDT, notional=500 USDT
    
    Note:
        MIN_NOTIONALæ£€æŸ¥åº”ä½¿ç”¨notional_valueï¼Œè€Œémarginï¼
    """
    # è®¡ç®—ä¿è¯é‡‘ï¼ˆå ç”¨è´¦æˆ·èµ„é‡‘ï¼‰
    margin = account_balance * (position_pct / 100)
    
    # è®¡ç®—åä¹‰ä»·å€¼ï¼ˆå®é™…äº¤æ˜“è§„æ¨¡ï¼‰
    notional_value = margin * leverage
    
    # è®¡ç®—äº¤æ˜“æ•°é‡
    quantity = notional_value / current_price
    
    return quantity, margin, notional_value
```

### 12. è‡ªåŠ¨æ–‡æ¡£ç”Ÿæˆ

```python
# scripts/generate_docs.py
def generate_api_docs():
    """ä»ä»£ç æ³¨é‡Šè‡ªåŠ¨ç”ŸæˆAPIæ–‡æ¡£"""
    import pdoc
    
    modules = [
        'src.data.processor',
        'src.risk.manager',
        'src.execution.engine'
    ]
    
    pdoc.pdoc(*modules, output_dir='docs/api')

def generate_data_flow_docs():
    """ä»å®é™…æ•°æ®ç”Ÿæˆæµç¨‹æ–‡æ¡£"""
    # è¿è¡Œä¸€æ¬¡å®Œæ•´æµç¨‹
    bot = TradingBot()
    bot.run_once()
    
    # æå–å„æ­¥éª¤çš„å®é™…æ•°æ®
    steps = bot.get_pipeline_data()
    
    # ç”Ÿæˆæ–‡æ¡£
    with open('docs/DATA_FLOW_ACTUAL.md', 'w') as f:
        for step_name, step_data in steps.items():
            f.write(f"## {step_name}\n\n")
            f.write(f"```python\n{step_data}\n```\n\n")
```

---

## ğŸ—ºï¸ å®æ–½è·¯çº¿å›¾

### Phase 1: ç´§æ€¥ä¿®å¤ï¼ˆ1-2å‘¨ï¼‰

**Week 1-2: é«˜å±é—®é¢˜ä¿®å¤**

- [ ] **ä¿®å¤MIN_NOTIONALé€»è¾‘** (P0)
  - ä¿®æ”¹æ£€æŸ¥å¯¹è±¡ï¼ˆä¿è¯é‡‘â†’åä¹‰ä»·å€¼ï¼‰
  - ä¿®æ­£total_valueå®šä¹‰
  - åˆ›å»ºå•å…ƒæµ‹è¯•
  - é¢„è®¡: 1å¤©

- [ ] **ä¿®å¤å¤šå‘¨æœŸæ•°æ®** (P0)
  - ä½¿ç”¨å·²å®ŒæˆKçº¿ï¼ˆdf.iloc[-2]ï¼‰
  - ä¿å­˜æ‰€æœ‰å‘¨æœŸåŸå§‹æ•°æ®
  - æ·»åŠ ç‹¬ç«‹æ€§éªŒè¯
  - é¢„è®¡: 2å¤©

- [ ] **ä¿®å¤snapshot_id** (P1)
  - æ·»åŠ ä¸Šä¸‹æ–‡ä¿¡æ¯
  - é™ä½ç¢°æ’é£é™©
  - æ›´æ–°æ–‡æ¡£
  - é¢„è®¡: 1å¤©

- [ ] **æå‡warmupæœŸ** (P1)
  - ä¿®æ”¹ä¸º105æ ¹
  - é‡æ–°å¤„ç†å†å²æ•°æ®
  - æ›´æ–°æ–‡æ¡£
  - é¢„è®¡: 1å¤©

### Phase 2: æ¶æ„ä¼˜åŒ–ï¼ˆ3-4å‘¨ï¼‰

**Week 3-4: æ¨¡å—é‡æ„**

- [ ] **é‡æ„DataProcessor**
  - åˆ†ç¦»æ•°æ®å¤„ç†å’Œç‰¹å¾å·¥ç¨‹
  - æ·»åŠ æ•°æ®éªŒè¯ç®¡é“
  - åˆ›å»ºFeatureEngineeræ¨¡å—
  - é¢„è®¡: 5å¤©

- [ ] **é‡æ„RiskManager**
  - å®ç°å¤šå±‚çº§é£æ§
  - åˆ›å»ºéªŒè¯å™¨æ¨¡å¼
  - æ·»åŠ æ­¢æŸ/æ­¢ç›ˆç®¡ç†å™¨
  - é¢„è®¡: 3å¤©

- [ ] **é‡æ„SnapshotManager**
  - ç»Ÿä¸€å¿«ç…§IDç®¡ç†
  - å®ç°å¤šç§ç”Ÿæˆæ¨¡å¼
  - æ·»åŠ IDè§£æåŠŸèƒ½
  - é¢„è®¡: 2å¤©

**Week 5-6: æµ‹è¯•ä½“ç³»**

- [ ] **å»ºç«‹å•å…ƒæµ‹è¯•**
  - æ•°æ®å¤„ç†æµ‹è¯•
  - é£æ§é€»è¾‘æµ‹è¯•
  - å¤šå‘¨æœŸæµ‹è¯•
  - ç›®æ ‡: >60%è¦†ç›–ç‡
  - é¢„è®¡: 5å¤©

- [ ] **å»ºç«‹é›†æˆæµ‹è¯•**
  - ç«¯åˆ°ç«¯æµç¨‹æµ‹è¯•
  - å¼‚å¸¸åœºæ™¯æµ‹è¯•
  - å›å½’æµ‹è¯•
  - é¢„è®¡: 3å¤©

- [ ] **æ€§èƒ½æµ‹è¯•**
  - å‹åŠ›æµ‹è¯•
  - å¹¶å‘æµ‹è¯•
  - å†…å­˜æ³„æ¼æ£€æµ‹
  - é¢„è®¡: 2å¤©

### Phase 3: ç›‘æ§å®Œå–„ï¼ˆ2å‘¨ï¼‰

**Week 7-8: ç›‘æ§å‘Šè­¦**

- [ ] **å®æ—¶ç›‘æ§ç³»ç»Ÿ**
  - æ•°æ®è´¨é‡ç›‘æ§
  - é£æ§æ‰§è¡Œç›‘æ§
  - æ€§èƒ½æŒ‡æ ‡ç›‘æ§
  - é¢„è®¡: 4å¤©

- [ ] **å¼‚å¸¸æ£€æµ‹**
  - å¤šå‘¨æœŸå¼‚å¸¸æ£€æµ‹
  - æŒ‡æ ‡è®¡ç®—å¼‚å¸¸æ£€æµ‹
  - é£æ§é€»è¾‘å¼‚å¸¸æ£€æµ‹
  - é¢„è®¡: 3å¤©

- [ ] **å‘Šè­¦ç³»ç»Ÿ**
  - é‚®ä»¶å‘Šè­¦
  - æ—¥å¿—å‘Šè­¦
  - Dashboardå¯è§†åŒ–
  - é¢„è®¡: 3å¤©

### Phase 4: æ–‡æ¡£è§„èŒƒï¼ˆ1å‘¨ï¼‰

**Week 9: æ–‡æ¡£å®Œå–„**

- [ ] **ä»£ç æ–‡æ¡£**
  - æ·»åŠ ç±»å‹æ³¨è§£
  - å®Œå–„docstring
  - è‡ªåŠ¨ç”ŸæˆAPIæ–‡æ¡£
  - é¢„è®¡: 2å¤©

- [ ] **æµç¨‹æ–‡æ¡£**
  - ä»å®é™…æ•°æ®ç”Ÿæˆæ–‡æ¡£
  - å»ºç«‹æ–‡æ¡£åŒæ­¥æœºåˆ¶
  - åˆ›å»ºç¤ºä¾‹å’Œæ•™ç¨‹
  - é¢„è®¡: 2å¤©

- [ ] **è¿ç»´æ–‡æ¡£**
  - éƒ¨ç½²æŒ‡å—
  - æ•…éšœæ’æŸ¥æ‰‹å†Œ
  - æ€§èƒ½è°ƒä¼˜æŒ‡å—
  - é¢„è®¡: 1å¤©

---

## ğŸ“Š æˆåŠŸæ ‡å‡†

### å…³é”®æŒ‡æ ‡

| æŒ‡æ ‡ | å½“å‰ | Phase 1 | Phase 2 | Phase 3 | Phase 4 |
|------|------|---------|---------|---------|---------|
| ä»£ç è¦†ç›–ç‡ | 10% | 20% | 60% | 75% | 80% |
| æ•°æ®éªŒè¯ç‡ | æ‰‹åŠ¨ | 50% | 80% | 100% | 100% |
| æ–‡æ¡£åŒæ­¥ç‡ | 60% | 70% | 85% | 95% | 100% |
| é£æ§å‡†ç¡®ç‡ | 85% | 95% | 98% | 99% | 100% |
| ç›‘æ§è¦†ç›–ç‡ | 0% | 20% | 50% | 90% | 100% |

### è´¨é‡æ£€æŸ¥æ¸…å•

#### æ•°æ®è´¨é‡
- [ ] å¤šå‘¨æœŸä»·æ ¼ç‹¬ç«‹æ€§ >99%
- [ ] æŠ€æœ¯æŒ‡æ ‡ç¬¦åˆç»å…¸å®šä¹‰ 100%
- [ ] WarmupæœŸå‡†ç¡®æ ‡è®° 100%
- [ ] æ•°æ®å®Œæ•´æ€§æ£€æŸ¥é€šè¿‡ç‡ 100%

#### é£æ§è´¨é‡
- [ ] MIN_NOTIONALæ£€æŸ¥å‡†ç¡®ç‡ 100%
- [ ] æ­¢æŸ/æ­¢ç›ˆæ–¹å‘æ­£ç¡®ç‡ 100%
- [ ] æ æ†æ§åˆ¶åˆè§„ç‡ 100%
- [ ] é£æ§è¯¯æ‹’ç‡ <0.1%

#### ä»£ç è´¨é‡
- [ ] å•å…ƒæµ‹è¯•è¦†ç›–ç‡ >80%
- [ ] é›†æˆæµ‹è¯•é€šè¿‡ç‡ 100%
- [ ] ä»£ç è§„èŒƒæ£€æŸ¥é€šè¿‡ç‡ 100%
- [ ] æ€§èƒ½æµ‹è¯•é€šè¿‡ç‡ 100%

#### æ–‡æ¡£è´¨é‡
- [ ] ä»£ç ä¸æ–‡æ¡£ä¸€è‡´æ€§ 100%
- [ ] APIæ–‡æ¡£å®Œæ•´æ€§ 100%
- [ ] ç¤ºä¾‹æ•°æ®å‡†ç¡®æ€§ 100%
- [ ] ç”¨æˆ·æ‰‹å†Œå¯è¯»æ€§ >90%

---

## ğŸš€ æ‰§è¡Œå»ºè®®

### å›¢é˜Ÿåˆ†å·¥

1. **æ•°æ®å›¢é˜Ÿ**
   - è´Ÿè´£æ•°æ®å¤„ç†æ¨¡å—é‡æ„
   - å¤šå‘¨æœŸæ•°æ®ä¼˜åŒ–
   - æ•°æ®éªŒè¯ç®¡é“

2. **é£æ§å›¢é˜Ÿ**
   - è´Ÿè´£é£æ§æ¨¡å—é‡æ„
   - å¤šå±‚çº§é£æ§å®ç°
   - é£æ§æµ‹è¯•

3. **æµ‹è¯•å›¢é˜Ÿ**
   - è´Ÿè´£æµ‹è¯•ä½“ç³»å»ºè®¾
   - å•å…ƒæµ‹è¯•/é›†æˆæµ‹è¯•
   - æ€§èƒ½æµ‹è¯•

4. **è¿ç»´å›¢é˜Ÿ**
   - è´Ÿè´£ç›‘æ§ç³»ç»Ÿ
   - å‘Šè­¦ç³»ç»Ÿ
   - éƒ¨ç½²ä¼˜åŒ–

### é‡Œç¨‹ç¢‘

**M1 (Week 2)**: æ‰€æœ‰é«˜å±é—®é¢˜ä¿®å¤å®Œæˆ
- MIN_NOTIONALé€»è¾‘ä¿®å¤ âœ…
- å¤šå‘¨æœŸæ•°æ®ä¿®å¤ âœ…
- ç´§æ€¥æµ‹è¯•é€šè¿‡ âœ…

**M2 (Week 6)**: æ¶æ„é‡æ„å®Œæˆ
- æ¨¡å—è§£è€¦ âœ…
- æµ‹è¯•è¦†ç›–ç‡>60% âœ…
- ä»£ç è§„èŒƒè¾¾æ ‡ âœ…

**M3 (Week 8)**: ç›‘æ§ç³»ç»Ÿä¸Šçº¿
- å®æ—¶ç›‘æ§ âœ…
- å¼‚å¸¸å‘Šè­¦ âœ…
- Dashboardå¯è§†åŒ– âœ…

**M4 (Week 9)**: æ–‡æ¡£è§„èŒƒå®Œæˆ
- ä»£ç æ–‡æ¡£100% âœ…
- æµç¨‹æ–‡æ¡£åŒæ­¥ âœ…
- è¿ç»´æ‰‹å†Œå®Œå–„ âœ…

---

## ğŸ“ æŒç»­æ”¹è¿›

### å®šæœŸå®¡æŸ¥

- **å‘¨ä¼š**: è¿›å±•åŒæ­¥ã€é—®é¢˜è®¨è®º
- **åŒå‘¨å›é¡¾**: é‡Œç¨‹ç¢‘æ£€æŸ¥ã€é£é™©è¯„ä¼°
- **æœˆåº¦æ€»ç»“**: KPI reviewã€ç»éªŒæ€»ç»“
- **å­£åº¦è§„åˆ’**: æˆ˜ç•¥è°ƒæ•´ã€èµ„æºåˆ†é…

### åé¦ˆæœºåˆ¶

- **ç”¨æˆ·åé¦ˆ**: æ”¶é›†ä½¿ç”¨é—®é¢˜å’Œå»ºè®®
- **ä»£ç å®¡æŸ¥**: Pull Requestå¼ºåˆ¶review
- **æµ‹è¯•æŠ¥å‘Š**: æ¯æ—¥è‡ªåŠ¨åŒ–æµ‹è¯•ç»“æœ
- **ç›‘æ§å‘Šè­¦**: å®æ—¶ç³»ç»Ÿå¥åº·çŠ¶æ€

### çŸ¥è¯†æ²‰æ·€

- **æŠ€æœ¯æ–‡æ¡£**: æ¶æ„è®¾è®¡ã€æœ€ä½³å®è·µ
- **é—®é¢˜åº“**: å¸¸è§é—®é¢˜åŠè§£å†³æ–¹æ¡ˆ
- **æ¡ˆä¾‹åˆ†æ**: æ•…éšœå¤ç›˜ã€ä¼˜åŒ–æ¡ˆä¾‹
- **åŸ¹è®­ææ–™**: æ–°äººonboardingã€æŠ€èƒ½æå‡

---

## ğŸ“ é™„å½•

### A. æŠ€æœ¯æ ˆ

**æ ¸å¿ƒæ¡†æ¶**:
- Python 3.10+
- Pandas 2.0+
- TA-Lib / ta
- pytest

**æ•°æ®å­˜å‚¨**:
- PostgreSQLï¼ˆç»“æ„åŒ–æ•°æ®ï¼‰
- Redisï¼ˆç¼“å­˜ï¼‰
- Parquetï¼ˆå†å²æ•°æ®ï¼‰

**ç›‘æ§å·¥å…·**:
- Prometheusï¼ˆæŒ‡æ ‡æ”¶é›†ï¼‰
- Grafanaï¼ˆå¯è§†åŒ–ï¼‰
- ELKï¼ˆæ—¥å¿—åˆ†æï¼‰

**CI/CD**:
- GitHub Actions
- Docker
- Kubernetesï¼ˆå¯é€‰ï¼‰

### B. å‚è€ƒèµ„æ–™

**é‡‘èç†è®º**:
- ã€ŠTechnical Analysis of the Financial Marketsã€‹
- Binance APIæ–‡æ¡£
- TradingViewæŒ‡æ ‡åº“

**è½¯ä»¶å·¥ç¨‹**:
- ã€ŠClean Codeã€‹
- ã€ŠClean Architectureã€‹
- ã€ŠTest-Driven Developmentã€‹

**é‡åŒ–äº¤æ˜“**:
- ã€ŠAlgorithmic Tradingã€‹
- ã€ŠQuantitative Tradingã€‹
- VNPY/Freqtradeå¼€æºé¡¹ç›®

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2025-12-18  
**ç»´æŠ¤è€…**: AI Trader Team  
**ä¸‹æ¬¡å®¡æŸ¥**: Phase 1å®Œæˆåï¼ˆé¢„è®¡2å‘¨åï¼‰

---

**æ„¿æ™¯**: æ‰“é€ ä¸€ä¸ªæ•°æ®å¯é ã€é£æ§ä¸¥æ ¼ã€æ¶æ„æ¸…æ™°çš„ä¸“ä¸šé‡åŒ–äº¤æ˜“ç³»ç»Ÿ ğŸš€
